# vim: set filetype=zsh :
# vim: set foldlevel=1 :

# Terminal {{{1

# ANSI Codes : Effets, Couleurs {{{2

# Code de la forme :

$'\E[0;30m'

# ou le 0 est le code de l’effet (attribut), ici aucun
# et le 30 est le code de la couleur

# Exemple :

echo $'\E[7;35m' coucou

# $'\E[
#
# 0 : défaut
# 1 : bold
# 2 : dim
# 3 : italic
# 4 : underline
# 5 : slow blink
# 6 : rapid blink
# 7 : reverse video
#
# ;
#
# 30 : black
# 31 : red
# 32 : green
# 33 : yellow
# 34 : blue
# 35 : magenta
# 36 : cyan
# 37 : white
#
# 90 : bright black
# 91 : bright red
# 92 : bright green
# 93 : bright yellow
# 94 : bright blue
# 95 : bright magenta
# 96 : bright cyan
# 97 : bright white
#
# m'

# }}}2

# }}}1

# Shell {{{1

# Aliases {{{2

alias psgrep='ps auxww | /bin/grep -v grep | /bin/grep --color=auto'

# }}}2

# Pipe heredoc {{{2

cat <<- 'FIN' | ed fichier
	/tutu/a
	ajout
	.
	w
FIN

# }}}2

# While read line from file {{{2

while read ligne
do
	eval $ligne

done < $fichier

# }}}2

# While read variable from pipe {{{2

file *.svg | grep 'PNG' | awk '{ print $1 }' | sed 's/://' | while read fichier
do
	racine=${fichier%.*}
	echo "mv $fichier ${racine}.png"
	mv $fichier ${racine}.png
done

# }}}2

# Example of ed script {{{2

# Les '...' autour de FIN sont nécessaires
# pour ne pas que le shell interprète les backslash

cat <<- 'FIN' | ed toto
	g/b/a\
	apres\
	.
	%p
	w
FIN

# }}}2

# Variable contenant le nom d’une autre variable {{{2

	Nargs=$#
	eval "nom=\$$Nargs"

	Nargs=$#
	nom=${(P)Nargs}

	echo nom=$nom

# }}}2

# Dialog output -> var via exec M>&N {{{2

# Fonctionne

exec 3>&1
choix=$(dialog --menu "Liste" 0 0 0 $=tagitem 2>&1 1>&3)
exec 3>&-

# Ne fonctionne pas

choix=$(dialog --menu "Liste" 80 80 80 $=tagitem 3>&1 1>&2 2>&3 3>&-)

# Ne fonctionne pas

exec 3>&1
choix=$(dialog --menu "Liste" 80 80 80 $=tagitem 1>&2 2>&3)
exec 3>&-

# }}}2

# Dialog output -> var via named pipe {{{2

tube=~/racine/run/fifo/dialog

dialog --menu "Liste" 0 0 0 $=tagitem 2> $tube &

read choix < $tube

# }}}2

# Stopper / Reprendre un groupe de processus {{{2

kill -STOP -- -$groupe
kill -CONT -- -$groupe

# }}}2

# Groupe d’un processus {{{2

groupe=($(ps -eo "%r %p" | awk '{ if ( $2 == '$processus' ) print $1 }'))

# }}}2

# Processus appartenant à un groupe {{{2

arbre=($(ps -eo "%r %p" |
	awk '{ if ( $1 == '$groupe' ) print $2 }'
))

# Si on veut exclure le script à la racine du groupe

script=$$

arbre=($(ps -eo "%r %p" |
	awk '{ if ( $1 == '$groupe' && $2 != '$script' ) print $2 }'
))

echo $arbre
echo

# }}}2

# Arbre d’un processus {{{2

pstree -p $processus

# }}}2

# Arbre de processus & Feuilles {{{2

arbre=($processus)

feuilles=()

echo Arbre : $arbre
echo

while (( $#arbre > 0 ))
do
	suivant=()

	for branche in $arbre
	do
		enfants=($(ps -eo "%P %p" |
			awk '{ if ( $1 == '$branche' ) print $2 }'
		))

		if (( $#enfants > 0 ))
		then
			# echo Enfants de $branche : $enfants
			# echo

			suivant+=($enfants)
		else
			feuilles+=$branche
		fi
	done

	arbre=($suivant)

	# echo Arbre : $arbre
	# echo
done

echo Feuilles : $feuilles
echo

# }}}2

# Envoyer un signal à un arbre de processus {{{2

# Credits :
# https://stackoverflow.com/questions/392022/whats-the-best-way-to-send-a-signal-to-all-members-of-a-process-group/6481337

signal-arbre () {

    local iden=$1
    local signal=${2:--STOP}

	 # needed to stop quickly forking parent from producing children
	 # between child killing and parent killing

    kill -stop $iden

	for enfant in $(ps -o pid --no-headers --ppid ${iden})
	do
        signal-arbre $enfant $signal
    done

    kill -$signal $iden
}

# }}}2

# }}}1

# Zsh {{{1

# Options {{{2

setopt extended_glob

setopt clobber

setopt local_options

setopt warn_create_global

setopt null_glob

setopt no_match
unsetopt null_glob

# }}}2

# Modules {{{2

zmodload zsh/regex

# }}}2

# Tableaux {{{2

# remove the ith element with
#
# foo[$i] =()
#
# instead.

# To remove element with content "b" from array:
#
# foo=(a b c)
# foo=(${foo#b})

# To remove element number $i: a=("${(@)a[1,$i-1]}" "${(@)a[$i+1,$#a]}")
#
# (The simpler construct a=($a[1,$i-1] $a[$i+1,$#a]) also removes empty elements.)
#
# ADDED:
#
# To remove any occurence of b: a=("${(@)a:#b}")
# :# is the hieroglyph to remove matching elements; "" and (@) is to operate correctly on arrays even if they contain empty elements.

# }}}2

# Placer les lignes d’un fichier dans un tableau {{{2

identifiants=( ${(f)"$(< $runfile)"} )

# Avec traitement des lignes {{{3

identifiants=( ${(f)"$(< $runfile | awk '{print $1}')"} )

# }}}3

# Lignes inversées & uniques {{{3

dirstack=( ${(fuOa)"$(< $REPERTOIRES_FICHIER)"} )

# }}}3

# }}}2

# Placer les lignes de la sortie d’une commande dans un tableau {{{2

processi=("${(f)$(psgrep minuterie.zsh)}")

# }}}2

# L’élément est-il dans le tableau ? {{{2

[[ $tableau[(i)$element] -le $#tableau ]]

(( ${foo[(i)b]} <= ${#foo} ))

[[ -n "${foo[(r)b]}" ]] && echo 'b was found.' || echo 'b was not found.'

[[ ${foo[(r)b]} == b ]]

(( ${foo[(I)b]} )) \
  && echo "it's in" \
  || echo "it's somewhere else maybe"

# }}}2

# While read variable from pipe {{{2

file (#i)**/*.svg | grep 'JPEG' | awk '{ print $1 }' | sed 's/://' | while read fichier
do
	racine=${fichier%.*}
	echo "mv $fichier ${racine}.jpg"
	mv $fichier ${racine}.jpg
done

# }}}2

# }}}1
